// File generated by the BNF Converter (bnfc 2.9.4.1).

package lang;

/** Fold Visitor */
public abstract class FoldVisitor<R,A> implements AllVisitor<R,A> {
    public abstract R leaf(A arg);
    public abstract R combine(R x, R y, A arg);

/* Program */
    public R visit(lang.Absyn.PStms p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.PFunctionalModeStms p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }

/* Stm */
    public R visit(lang.Absyn.DefFun p, A arg) {
      R r = leaf(arg);
      r = combine(p.functype_.accept(this, arg), r, arg);
      for (lang.Absyn.Arg x : p.listarg_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.DefConstructor p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Arg x : p.listarg_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.DefClass p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.DefClassInherits p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPrint p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SBreak p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.SContinue p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.InitialiseStm p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_initialise_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.DeclareStm p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_declare_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.AssignStm p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_assign_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.LoopStm p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_loop_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.IncrnDecrmStm p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_incrmdecrm_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SCall p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SAppend p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SRemove p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SReturn p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.SObjInit p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Exp x : p.listexp_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SConstInit p, A arg) {
      R r = leaf(arg);
      r = combine(p.vartype_.accept(this, arg), r, arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.IfS p, A arg) {
      R r = leaf(arg);
      r = combine(p.if_stm_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.Block p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }

/* Item */
    public R visit(lang.Absyn.LstItem p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }

/* Stm_Initialise */
    public R visit(lang.Absyn.SInit p, A arg) {
      R r = leaf(arg);
      r = combine(p.vartype_.accept(this, arg), r, arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }

/* Stm_Declare */
    public R visit(lang.Absyn.SDecl p, A arg) {
      R r = leaf(arg);
      r = combine(p.vartype_.accept(this, arg), r, arg);
      return r;
    }

/* Stm_Assign */
    public R visit(lang.Absyn.SAssign p, A arg) {
      R r = leaf(arg);
      r = combine(p.assign_op_.accept(this, arg), r, arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }

/* Stm_IncrmDecrm */
    public R visit(lang.Absyn.SIncrmDecrm p, A arg) {
      R r = leaf(arg);
      r = combine(p.incrmdecrm_op_.accept(this, arg), r, arg);
      return r;
    }

/* Stm_Loop */
    public R visit(lang.Absyn.SWhile p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPLoopIdent p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPLoopList p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Item x : p.listitem_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPLoopRangeStart p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPLoopRangeStartStop p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SPLoopRangeStartStopEnd p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      r = combine(p.exp_3.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SCLoop p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_initialise_.accept(this, arg), r, arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      r = combine(p.stm_incrmdecrm_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SCLoopAssign p, A arg) {
      R r = leaf(arg);
      r = combine(p.stm_initialise_.accept(this, arg), r, arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      r = combine(p.stm_assign_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }

/* If_Stm */
    public R visit(lang.Absyn.SIf p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SIfElse p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_1)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      for (lang.Absyn.Stm x : p.liststm_2)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.SIfElseIf p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      r = combine(p.if_stm_.accept(this, arg), r, arg);
      return r;
    }

/* Arg */
    public R visit(lang.Absyn.ArgDecl p, A arg) {
      R r = leaf(arg);
      r = combine(p.vartype_.accept(this, arg), r, arg);
      return r;
    }

/* Exp */
    public R visit(lang.Absyn.EInt p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ENegInt p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EChar p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EDouble p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ENegDouble p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EString p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ETrue p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EFalse p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EId p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EListItem p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EListWith p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EListWithout p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EList p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Item x : p.listitem_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EListSize p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EInput p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.EStrLength p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ERand p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ETypeCast p, A arg) {
      R r = leaf(arg);
      r = combine(p.typecast_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ELambda p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Arg x : p.listarg_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      for (lang.Absyn.Stm x : p.liststm_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EMapIdent p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EMapList p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Item x : p.listitem_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EFilterIdent p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EFilterList p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Item x : p.listitem_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EReduceIdent p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EReduceList p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      for (lang.Absyn.Item x : p.listitem_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.ESelect p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.ESelectListItem p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ECall p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Exp x : p.listexp_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EObjCall p, A arg) {
      R r = leaf(arg);
      for (lang.Absyn.Exp x : p.listexp_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }
    public R visit(lang.Absyn.EPow p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EMul p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EDiv p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EMod p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EAdd p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ESub p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ELt p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EGt p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ELEq p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EGEq p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EEq p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.ENEq p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EAnd p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }
    public R visit(lang.Absyn.EOr p, A arg) {
      R r = leaf(arg);
      r = combine(p.exp_1.accept(this, arg), r, arg);
      r = combine(p.exp_2.accept(this, arg), r, arg);
      return r;
    }

/* Assign_Op */
    public R visit(lang.Absyn.Assign p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.AssignMul p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.AssignDiv p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.AssignMod p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.AssignAdd p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.AssignSub p, A arg) {
      R r = leaf(arg);
      return r;
    }

/* IncrmDecrm_Op */
    public R visit(lang.Absyn.Increment p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.Decrement p, A arg) {
      R r = leaf(arg);
      return r;
    }

/* FuncType */
    public R visit(lang.Absyn.FuncType_void p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.FuncTypeVarType p, A arg) {
      R r = leaf(arg);
      r = combine(p.vartype_.accept(this, arg), r, arg);
      return r;
    }

/* VarType */
    public R visit(lang.Absyn.VarType_int p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_double p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_bool p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_char p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_string p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_auto p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_func p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.VarType_object p, A arg) {
      R r = leaf(arg);
      return r;
    }

/* TypeCast */
    public R visit(lang.Absyn.TypeCast_toInt p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.TypeCast_toDouble p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.TypeCast_toBool p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.TypeCast_toChar p, A arg) {
      R r = leaf(arg);
      return r;
    }
    public R visit(lang.Absyn.TypeCast_toString p, A arg) {
      R r = leaf(arg);
      return r;
    }


}
